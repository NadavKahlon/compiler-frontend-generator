// TODO create a whole module for this, complete with explicit data structures

use std::cmp::Ordering;

use crate::handles::{Handle, Handled};

/// [Handled] types whose handles can be compared by order.
///
/// This trait requires no special implementations, and currently exists for symbolic purposes
/// only. When a type implements this trait, it indicates that the type's handles compared by the
/// order of their identifying serial numbers.
///
/// This means, for example, that handles to an [OrderlyHandled] type, generated by a
/// [HandledVec](crate::handles::collections::HandledVec), can be compared by their order of
/// insertion into this collection.
///
/// # Example
/// ```rust
/// # use syntax_parser_generator::handles::{Handle, Handled};
/// # use syntax_parser_generator::handles::collections::HandledVec;use syntax_parser_generator::handles::specials::OrderlyHandled;
///
/// struct LinkedListNode {
///     num: u32,
///     next: Option<Handle<LinkedListNode>>,
/// }
/// impl Handled for LinkedListNode { type HandleCoreType = u8; }
/// impl OrderlyHandled for LinkedListNode {}
///
/// let mut nodes = HandledVec::new();
/// let tail_handle = nodes.insert(LinkedListNode { num: 1337, next: None });
/// let head_handle = nodes.insert(LinkedListNode { num: 42, next: Some(tail_handle) });
///
/// assert!(tail_handle < head_handle)
/// ```
pub trait OrderlyHandled: Handled {}

impl<T> Ord for Handle<T>
where
    T: OrderlyHandled,
{
    fn cmp(&self, other: &Self) -> Ordering {
        self.core.cmp(&other.core)
    }
}

impl<T> PartialOrd for Handle<T>
where
    T: OrderlyHandled,
{
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.core.partial_cmp(&other.core)
    }
}
